---
layout:     post
title:      (DP문제) 2×n 타일링
author:     쭌프로
tags: 		  알고리즘 C언어 동적계획법 타일문제
subtitle:   DP를 활용한 11726번 문제 2×n 타일링
category:   알고리즘
---
<!-- Start Writing Below in Markdown -->

![Description]({{ site.url }}/img/ag-bg.png)

<p>알고리즘을 작업한 언어는 `C언어` 입니다.</p>

#동적 계획법(Dynamic Programming)

## 백준의 알고리즘 문제 - 11726번 문제 2×n 타일링

출처 : <a href="https://www.acmicpc.net/problem/11719">https://www.acmicpc.net/problem/11726</a>

## 문제:

<p>
  2×n 크기의 직사각형을 1×2, 2×1 타일로 채우는 방법의 수를 구하는 프로그램을 작성하시오.
  아래 그림은 2×5 크기의 직사각형을 채운 한 가지 방법의 예이다.
</p>
![Description]({{ site.url }}/img/2019-04-14-1.png)

## 입력:

<p>
  첫째 줄에 n이 주어진다. (1 ≤ n ≤ 1,000)
</p>

## 출력:

<p>
  첫째 줄에 2×n 크기의 직사각형을 채우는 방법의 수를 10,007로 나눈 나머지를 출력한다.
</p>

## 예제입력 -> 예제출력:
{% highlight matlab %}

  2 = 2
  
  9 = 55
{% endhighlight %}

## 쭌프로의 풀이

<p>
  1 X 2 <br/>
  ㅁㅁ <br/>
</p>
<p>
  2 X 1 <br/>
  ㅁ <br/>
  ㅁ <br/>
</p> 
<p>
  두가지의 타일을 활용하여 칸 수를 체우면 됩니다. <br/>
</p>

## n = 1 의 경우
<p>
  2 X 1 <br/>
  ㅁ <br/>
  ㅁ <br/> 
  <br/>
  이므로 2 X 1 (1 개) 사용
</p>

## n = 2 의 경우
<p>
  2 X 2 <br/>
  ㅁㅁ <br/>
  ㅁㅁ <br/> 
  <br/>
  이므로 2 X 1 (2 개) 사용 or 1 X 2 (2 개) 사용 (총 2가지 경우의 수)
</p>

## n = 3 의 경우
<p>
  2 X 3 <br/>
  ㅁㅁㅁ <br/>
  ㅁㅁㅁ <br/> 
  <br/>
  이므로 2 x 1 (3 개) or 1 x 2 (2 개), 2 x 1 (1 개) 사용 or 2 x 1 (1 개), 1 x 2 (2 개) 사용 (총 3가지 경우의 수)
</p>

<p>
  각각의 총 경우의 수는 n 개씩 늘어날 때마다 n개씩 늘어납니다. <br/>
  이렇게 DP 문제는 문제 속의 규칙성을 찾아서 점화식을 세워 풀어야 합니다.
</p>

## n 이 무수히 많을경우

![Description]({{ site.url }}/img/2019-04-14-2.png)

<p>
  개인적으로 이해하기 쉽도록 그림을 그려보았습니다.
</p>
<p>
  만약에 n 이 무수하게 많고 <br/>
  타일을 1개를 추가 할경우 <br/>
  (2 X 1) 한가지 경우만 존재하므로 <br/>
  앞에는 n - 1 개가 되고
</p>
<p>
  타일을 2개를 추가 할경우 <br/>
  (2 X 1, 2 X 1) or (1 X 2, 1 X 2) 4가지의 경우가 <b>존재 하지만</b> <br/>
  (2 X 1, 2 X 1) 의 경우 이미 n - 1 개에서 중복된 방법이므로 <br/>
  DP 공식에 따라 다시 값을 저장하지 않습니다. <br/>
  그러므로 남는 방법은 (1 X 2, 1 X 2) 2가지의 경우의 수만 남습니다. <br/>
  그러면 n - 2 가 됩니다.
</p>
<p>
  타일을 3개를 추가 할경우 <br/>
  (2 X 1, 2 X 1, 2 X 1) or (2 X 1, 1 X 2) or (1 X 2, 2 X 1) <br/>
  3개 이상의 경우의 수 부터는 위에서 이미 중복되는 <br/>
  경우의 수로 이루어져 있기 때문에  <br/>
  새로운 값을 저장하지 않습니다.
</p>
<p>
  따라서 가장 마지막에 오는 타일의 기준으로 <br/>
  생각했을 때 가능한 경우는 오직 두 가지 경우의 수  <br/>
  이를 점화식으로 나타내면 <br/>
  <b>D[i] = D[i - 1] + D[i - 2]</b> <br/>
  입니다.
</p>

<script src="https://gist.github.com/alalstjr/388414ba156160af1777f69a55f6d9bc.js"></script>

## 쭌프로 풀이 후기
<p>
  아무래도 DP 활용법이 많이 미숙하기 때문에 <br/>
  검색을 통해서 힌트를 얻고 나름 공식을 이해하였습니다. <br/>
  처음엔 주석으로 하나씩 써보며 공식을 찾아보기도 하고 <br/>
  너무 이해가 안갈때는 그림을 그려가며 문제를 이해하려고 노력했습니다. <br/>
  솔직히 100%! 이해했다는 아니라서 더 노력해야 할꺼같습니다. <br/>
  디버깅을 해가며 어떻게 동작하는지 더 자세하게 파고 들어야 할꺼같습니다.
</p>

## 참고 자료
<p>
  직접 검색해보고 최고의 설명이다! 라고 생각드는 블로그 주소를 정리해 두었습니다. <br/>
  <a href="https://www.youtube.com/watch?v=YHZiWaL49HY">
    안경잡이 개발자(나동빈)님의 유튜브 - DP 타일링 문제 풀어보기  
  </a>
</p>
