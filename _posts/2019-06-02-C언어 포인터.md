---
layout:     post
title:      C언어 포인터
author:     쭌프로
tags:       C언어
subtitle:   C언어 포인터 공부 노트
category:   C언어
---

<!-- Start Writing Below in Markdown -->

![Description]({{ site.url }}/img/c_bg.png)

<a href="https://github.com/alalstjr/C-Language/tree/master/1906">Git 코드 저장소</a>

# 포인터의 개념

일반적인 변수는 그 자체로 자신의 자료형에 맞는 값을 저장하지만 <b>포인터(Pointer) 변수</b>는 특이한 변수로, 
<b>특정한 변수의 메모리 주소</b>를 저장합니다. 
메모리 주소값을 저장할때 단순하게 주소값만 저장하는 것이 아닌 <b>어떠한 자료형의 주소값</b>인지 함께 저장을 합니다.

> int(1x4583) ----- int*(4583)

이렇듯 주소값을 가리킬 수 있습니다.

> int a = 5(0xAFB03954); ----- int *b = &a(0xAFB03954)(0xCA29839F);

포인터 변수 b는 int a 의 <b>주소값(0xAFB03954) 자체를 내부적</b>으로 가지게 됩니다. <br/>
또한 <b>b도 변수이기 때문에 특정한 주소값(0xCA29839F)</b>을 내부적으로 가지고 있습니다.

즉 각기 다른 주소에 저장된 a와 b의 변수 이며 b라는 것은 포인터 변수이기 때문에 a의 주소값을 가지고 있는 것입니다.

## 포인터변수의 선언 방법

- int *b 처럼 포인터를 선언할 <b>때는 * 붙입니다.</b>
- 이후에 *b 라고 쓰게 되면, 이것은 포인터 변수 b가 가리키는 <b>주소값을 의미</b>합니다.
- 위 예제를 다시 본다면 (int *b = &a) 에서 b는 5라는 값 자체가 됩니다.
- *b 은 현재 포인터가 가리키고 있는 <b>주소에 들어있는 값을 참조한다 해서 간접참조연산자</b> 라 부릅니다.
- 포인터와 간접참조연산자의 구분

> int *b = &a; 포인터 연산자 || *b 는 간접참조연산자

# 포인터 관련 연산자

- 주소 연산자(&) : 변수 앞에 붙어서 <b>변수의 메모리 시작 주소 값</b>을 구합니다.
- 포인터(*) : <b>포인터 변수를 선언</b>할 때 사용합니다.
- 간접 참조 연산자(*) : 선언된 <b>포인터 변수가 가리키는 변수</b>를 구합니다.

## 포인터 예제확인

{% highlight matlab %}

  #include <stdio.h>

  int main(void) {
    int a = 5;
    int *b = &a;
    printf("%d\n", *b);

    system("pause");
    return 0;
  }
{% endhighlight %}

> 결과 : 5

실제로 int a = 5;와 같은 변수를 할당하면 메모리 주소상에서는 다음과 같이 기록이 됩니다.

|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|:--------:|
|223|224|225|226|227|228|229|230|231|
|...|...|값|값|값|값|...|...|...|

int 형은 4바이트를 차지하므로 메모리 주소를 1바이트 씩 표현할 때 4칸을 차지합니다.

좀더 자세하게 확인하기 위해서 메모리 주소를 찍어보겠습니다.

{% highlight matlab %}

  #include <stdio.h>

  int main(void) {
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int i;

    for (i = 0; i < 10; i++) 
    {
      printf("%d\n", &a[i]);
    }

    system("pause");
    return 0;
  }
{% endhighlight %}

결과

{% highlight matlab %}

  15726640
  15726644
  15726648
  15726652
  15726656
  15726660
  15726664
  15726668
  15726672
  15726676
{% endhighlight %}

끝자리에 4 바이트 씩 증가하며 총 40 메모리가 배열에 저장된 것을 확인할 수 있습니다.

# 포인터의 기능과 주의할 점

- 포인터는 컴퓨터 시스템의 특정한 메모리에 <b>바로 접근</b>할 수 있습니다.
- 따라서 <b>기존에 존재하던 중요한 메모리 영역에 접근하지 않도록</b> 해야 합니다.

> int *a = 0x33484735; ----- *a = 0 

해당 주소값이 무엇인지 확실하게 알 수 없기 때문에
이런식으로 주소값에 직접 접근하여 값을 수정하는것은 매우 위험한 일입니다.

- <b>다중 포인터 변수</b> 포인터 변수는 포인터 변수를 가질 수 있습니다.

{% highlight matlab %}

  #include <stdio.h>

  int main(void) {
    int a = 5;
    int *b = &a;
    int c** = b&;
    printf("%d\n", **c);

    system("pause");
    return 0;
  }
{% endhighlight %}

## 배열과 포인터는 동일하다.

- 배열을 선언한 이후에는 그 이름 자체가 포인터 변수와 동일합니다.

{% highlight matlab %}

  #include <stdio.h>

  int main(void) {
    int a[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    int *b = a;
    printf("%d\n", b[2]);

    system("pause");
    return 0;
  }
{% endhighlight %}

변수 b에 a값을 담을때 따로 주소값을 작성하지 않아도 정상적으로 값이 참조 됩니다.
그 이유는 a[] 배열 자체로 이미 주소값으로 사용하고 있기 때문입니다.
