---
layout:     post
title:      동적계획법 이란?
author:     쭌프로
tags: 		  알고리즘 동적계획법
subtitle:   동적계획법(다이나믹 프로그래밍) 간단 요약
category:   알고리즘
---
<!-- Start Writing Below in Markdown -->


![Description]({{ site.url }}/img/ag-bg.png)

#동적 계획법(Dynamic Programming)

<a href="https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EA%B3%84%ED%9A%8D%EB%B2%95">위키백과 - 동적 계획법</a>

<p>
  수학자인 <b>리처드 벨만</b>이 1940년대에 사용하던 용어이며 <br/>
  복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법입니다.
</p>

<p>
  <b>동적 계획법</b>의 원리는 주어진 문제를 풀기 위해서, <br/>
  문제를 여러 개의 하위 문제(subproblem)로 나누어 푼 다음, <br/>
  그것을 결합하여 최종적인 목적에 도달하는 것이다. 
</p>

<p>
  이러한 <b>동적 계획법</b>의 장점으로는 <br/>
  하위 문제의 해결을 계산한 뒤, <br/>
  그 해결책을 저장하여 후에 같은 하위 문제가 나왔을 경우 <br/>
  저장된 해결책을 재활용하여 간단하게 해결하며 내려가므로 <br/>
  계산 횟수를 줄일 수 있다.<br/>
  저장된 해결책을 재활용하는것을 <b>메모이제이션</b> 이라고 부릅니다.
</p>

<p>
  <b>동적 계획법</b>은 문제를 해결하기 위한 <b>모든 방법을 검토</b>하고, 그 중에 <b>최적의 풀이법</b>을 찾아내기 때문에 <br/>
  <b>최단 경로 문제</b>, 행렬의 제곱 문제 등의 최적화에 사용됩니다.
</p>

# 그리디 알고리즘과의 비교

<p>
  <b>그리디 알고리즘</b>과 <b>동적 계획법</b>을 비교하며 둘의 특성을 알아보도록 하겠습니다.
</p>

## 동적 계획법

![Description]({{ site.url }}/img/2019-04-11-1.png)

<p>
  위 그림을 예제로 <br/>
  1번 루트 실행 후 값을 저장 <br/>
  2번 루트 실행 후 값을 저장 <br/>
  3번 루트 실행 후 값을 저장 <br/>
  (만약에 중복되는 루트가 있으면 실행하지 않습니다.) <br/>
  모든 루트를 비교하여 최단의 루트를 찹아냅니다. <br/>
  모든 방법을 검토하여 그중에서 최적의 풀이법을 찾아내는 알고리즘 <b>동적 계획법</b>
</p>

## 그리디 알고리즘

![Description]({{ site.url }}/img/2019-04-11-2.png)

<p>
  <b>동적 계획법</b>의 단점으로 최적의 루트를 찾기위해서 모든 루트를 검토해야하는 단점이있지만 <br/>
  <b>그리디 알고리즘</b>은 그 순간의 경로를 비교하여 최적의 경로로 최적의 루트를 찾아가는 특징이 있습니다. <br/>
</p>

## 비교 결론

<p>
  <b>동적 계획법</b>은 약간의 시간이 걸린다는 단점이 있지만 확실하게 가장 빠른 결로를 안내 해주는 장점이 있습니다. <br/>
  <b>그리디 알고리즘</b>은 즉효성이 있는 대신, 항상 최적의 루트를 구해주지는 않는다.
</p>

## 동적 계획법 예제
<p>
  대표적인 예시로 피보나치 수열 <br/>
  특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합을 구하는것
</p>

<p>
  <b>피보나치 수열의 점화식</b> : D[i] = D[i - 1] + D[i - 2] <br/>
  위 공식에 따라서 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 .... <br/>
  1 + 1 = 2 다음 1 + 2 = 3 다음 3 + 5 = 8 ... 이런식으로 나아갑니다.
</p>

<p>
  단순하게 분할 정복 기법(문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘) <br/>
  이용하여 15번째 피보나치 수열을 구한다면 <br/>
  D[15]를 구하려면 D[14]와 D[13] 을 알아야 하며 <br/>
  D[14]를 구하려면 D[13]과 D[12] 를 알아햐 합니다. <br/>
  하지만 여기서 발생하는 문제는 D[13]이 중복되어 들어가는것입니다. <br/>
  계속 하여 하위로 내려 갈수록 중복되는 값이 중첩되어 많은 시간이 소비될 수 있습니다. <br/>
  이를 해결하기 위해서 동적 계획법을 사용하는것 입니다.
</p>

<script src="https://gist.github.com/alalstjr/4090e06fe46ff8e63ba93e16419c5cc5.js"></script>
<p>
  dp 값을 10 으로 주면 바로 값이 55 를 출력하여 <br/>
  수열 값을 계산하는 것을 확인할 수 있지만 <br/>
  dp 값을 50 을 주는순간 n^50 으로 수많은 계산을 해야 하기때문에 <br/>
  결과를 확인하는데 엄청난 시간이 걸리는 것을 확인 할 수 있습니다. <br/>
  이를 해결하기 위해서 메모이제이션을 구현하는것입니다.
</p>

<script src="https://gist.github.com/alalstjr/23e11524d0c86e25fb89f3801b33dea5.js"></script>
<p>
  d[] 배열을 만들어 수열의 각 결과값을 저장하여 <br/>
  각각의 피보나치 수열의 값이 d[]배열에 존재하면 해당 값을 배열에서 꺼내서 재활용하고 <br/>
  해당 값이 없다면 d[] 배열에 값을 저장합니다.
</p>

![Description]({{ site.url }}/img/2019-04-11-3.png)

## 좀더 자세하게 알고싶다면?
<p>
  직접 검색해보고 최고의 설명이다! 라고 생각드는 블로그 주소를 정리해 두었습니다. <br/>
  <a href="https://blog.naver.com/PostView.nhn?blogId=ndb796&logNo=221233570962&redirect=Dlog&widgetTypeCall=true&directAccess=false">
    안경잡이 개발자(나동빈)님의 블로그
  </a> <br/>
  <a href="https://www.youtube.com/watch?v=FmXZG7D8nS4">안경잡이 개발자(나동빈)님의 유튜브</a> <br/>
  <a href="https://www.leafcats.com/71">복세편살 개발라이프님의 블로그</a>
</p>
